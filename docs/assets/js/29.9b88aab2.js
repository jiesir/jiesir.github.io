(window.webpackJsonp=window.webpackJsonp||[]).push([[29],{382:function(e,t,v){"use strict";v.r(t);var _=v(42),a=Object(_.a)({},(function(){var e=this,t=e.$createElement,v=e._self._c||t;return v("ContentSlotsDistributor",{attrs:{"slot-key":e.$parent.slotKey}},[v("h1",{attrs:{id:"vue生命周期"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#vue生命周期"}},[e._v("#")]),e._v(" Vue生命周期")]),e._v(" "),v("h2",{attrs:{id:"请详细说下你对vue生命周期的理解"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#请详细说下你对vue生命周期的理解"}},[e._v("#")]),e._v(" 请详细说下你对vue生命周期的理解")]),e._v(" "),v("ul",[v("li",[v("p",[v("strong",[e._v("beforeCreate")]),e._v(" （创建前）vue实例的挂载元素$el和数据对象 data都是undefined, 还未初始化")])]),e._v(" "),v("li",[v("p",[v("strong",[e._v("created")]),e._v(" (创建后) 完成了 data数据初始化, el还未初始化;实例已经创建完成，因为它是最早触发的原因可以进行一些数据，资源的请求。")])]),e._v(" "),v("li",[v("p",[v("strong",[e._v("beforeMount")]),e._v(" (载入前) vue实例的$el和data都初始化了, 相关的render函数首次被调用。实例已完成以下的配置：编译模板，把data里面的数据和模板生成html。注意此时还没有挂载html到页面上。")])]),e._v(" "),v("li",[v("p",[v("strong",[e._v("mounted")]),e._v(" (载入后) 在el 被新创建的 vm.$el替换，并挂载到实例上去之后调用。实例已完成以下的配置：用上面编译好的html内容替换el属性指向的DOM对象。完成模板中的html渲染到html页面中。此过程中进行ajax交互")])]),e._v(" "),v("li",[v("p",[v("strong",[e._v("beforeUpdate")]),e._v(" (更新前) 在数据更新之前调用，发生在虚拟DOM重新渲染和打补丁之前。可以在该钩子中进一步地更改状态，不会触发附加的重渲染过程。")])]),e._v(" "),v("li",[v("p",[v("strong",[e._v("updated")]),e._v(" （更新后） 在由于数据更改导致的虚拟DOM重新渲染和打补丁之后调用。调用时，组件DOM已经更新，所以可以执行依赖于DOM的操作。然而在大多数情况下，应该避免在此期间更改状态，因为这可能会导致更新无限循环。该钩子在服务器端渲染期间不被调用。")])]),e._v(" "),v("li",[v("p",[v("strong",[e._v("beforeDestroy")]),e._v(" (销毁前） 在实例销毁之前调用。实例仍然完全可用。")])]),e._v(" "),v("li",[v("p",[v("strong",[e._v("destroyed")]),e._v(" (销毁后） 在实例销毁之后调用。调用后，所有的事件监听器会被移除，所有的子实例也会被销毁。该钩子在服务器端渲染期间不被调用。")])])]),e._v(" "),v("p",[v("img",{attrs:{src:"/docs/interview/img8.png",alt:"img8"}})]),e._v(" "),v("p",[v("img",{attrs:{src:"/docs/interview/img9.png",alt:"img9"}})]),e._v(" "),v("p",[v("img",{attrs:{src:"/docs/interview/img10.png",alt:"img10"}})]),e._v(" "),v("h2",{attrs:{id:"ajax请求放在哪个生命周期中"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#ajax请求放在哪个生命周期中"}},[e._v("#")]),e._v(" ajax请求放在哪个生命周期中")]),e._v(" "),v("p",[e._v("理解:")]),e._v(" "),v("ul",[v("li",[e._v("在"),v("code",[e._v("created")]),e._v("的时候，视图中的 "),v("code",[e._v("dom")]),e._v(" 并没有渲染出来，所以此时如果直接去操 "),v("code",[e._v("dom")]),e._v(" 节点，无法找到相关的元素")]),e._v(" "),v("li",[e._v("在"),v("code",[e._v("mounted")]),e._v("中，由于此时 "),v("code",[e._v("dom")]),e._v(" 已经渲染出来了，所以可以直接操作 "),v("code",[e._v("dom")]),e._v(" 节点一般情况下都放到 "),v("code",[e._v("mounted")]),e._v(" 中,保证逻辑的统一性,因为生命周期是同步执行的， "),v("code",[e._v("ajax")]),e._v(" 是异步执行的")])]),e._v(" "),v("div",{staticClass:"custom-block tip"},[v("p",{staticClass:"custom-block-title"},[e._v("TIP")]),e._v(" "),v("p",[e._v("服务端渲染不支持mounted方法，所以在服务端渲染的情况下统一放到created中")])]),e._v(" "),v("h2",{attrs:{id:"何时需要使用beforedestroy"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#何时需要使用beforedestroy"}},[e._v("#")]),e._v(" 何时需要使用beforeDestroy")]),e._v(" "),v("p",[e._v("理解:")]),e._v(" "),v("ul",[v("li",[e._v("可能在当前页面中使用了 "),v("code",[e._v("$on")]),e._v(" 方法，那需要在组件销毁前解绑。")]),e._v(" "),v("li",[e._v("清除自己定义的"),v("code",[e._v("定时器")])]),e._v(" "),v("li",[e._v("解除事件的绑定 "),v("code",[e._v("scroll mousemove")]),e._v(" …")])])])}),[],!1,null,null,null);t.default=a.exports}}]);